{"version":3,"sources":["1/script.js"],"names":["console","log","width","window","innerWidth","height","innerHeight","canvas","document","getElementById","context","getContext","roads_canvas","createElement","roads_context","watercolor_canvas","image","data","watercolor_context","drawingId","boids","querySelector","addEventListener","e","clientX","clientY","push","Boid","Math","random","PI","setInterval","drawing","dist","x1","y1","x2","y2","sqrt","x","y","angle","gen","pow","dx","cos","dy","sin","stride","life","dead","hue","update","strokeStyle","beginPath","moveTo","lineTo","stroke","trail","color","lineWidth","i","px","py","index","floor","kill","splice","indexOf","bubbleFrequency","getImageData","length","boid","clearRect","globalAlpha","drawImage","clearInterval"],"mappings":"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","file":"script.506144d1.js","sourceRoot":"../src","sourcesContent":["import \"./style.css\";\nconsole.log(\"load\");\n\nvar width = window.innerWidth;\nvar height = window.innerHeight;\n\nvar canvas = document.getElementById(\"world\");\ncanvas.width = width;\ncanvas.height = height;\nvar context = canvas.getContext(\"2d\");\n\nvar roads_canvas = document.createElement(\"canvas\");\nroads_canvas.width = width;\nroads_canvas.height = height;\nvar roads_context = roads_canvas.getContext(\"2d\");\n\nvar watercolor_canvas = document.createElement(\"canvas\");\nwatercolor_canvas.width = width;\nwatercolor_canvas.height = height;\nvar watercolor_context = watercolor_canvas.getContext(\"2d\");\n\nvar image, data;\nvar drawingId = -1;\nvar boids = [];\n\ndocument.querySelector(\"canvas#world\").addEventListener(\"click\", (e) => {\n  const { clientX, clientY } = e;\n  boids.push(\n    new Boid(clientX, clientY, (Math.random() * 180 * Math.PI) / 180, 0)\n  );\n  if (drawingId === -1) {\n    drawingId = setInterval(() => {\n      drawing(0.015);\n    }, 1000 / 60);\n  }\n});\n\n// functions\nvar dist = function (x1, y1, x2, y2) {\n  return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n};\n\nvar Boid = function (x, y, angle, gen) {\n  // 초기값 설정\n  // x, y : 그리기 시작점\n  // angle, dx, dy : 랜덤 설정된 각도에 따라 거리 1만큼 이동시키기 위한 x, y 델타값\n  // stride : 한 틱당 그릴 선분의 길이를 정하기 위한 보폭.\n  //        값이 클 수록 한 번에 길게 그리므로, 더 적은 틱으로 수행 가능하다.\n  // life, gen : 나중에 추가되는 자식일수록 gen이 높고, gen이 life보다 높으면 바로 kill()한다.\n  //            프랙탈 구조가 너무 좁게 들어가는 걸 방지함.\n  // dead : 계속 그릴지, 삭제할지를 판단하는 플래그\n  // dist : 시작점과 캔버스 중심과의 거리\n  // hue : 색상 관련\n\n  this.x = x;\n  this.y = y;\n  this.angle = Math.pow(Math.random(), 10) + angle;\n  this.dx = Math.cos(this.angle);\n  this.dy = Math.sin(this.angle);\n  this.stride = 2;\n  this.life = Math.random() * 30 + 10;\n  this.gen = gen;\n  this.dead = false;\n  this.dist = dist(this.x, this.y, width / 2, height / 2);\n  this.hue = Math.random() * 120;\n\n  // update함수가 실행되면서 선이 그려진다.\n\n  this.update = function () {\n    roads_context.strokeStyle = \"#808080\";\n    roads_context.beginPath();\n    roads_context.moveTo(this.x, this.y);\n\n    this.x += this.dx * this.stride;\n    this.y += this.dy * this.stride;\n\n    this.dist = dist(this.x, this.y, width / 2, height / 2);\n\n    roads_context.lineTo(this.x, this.y);\n    roads_context.stroke();\n\n    // trail : 음영 색 길이\n    // var trail = Math.random() * ((50 - 10) * ((this.dist / width) * 2)) + 10;\n    var trail = (Math.random() * Math.random() * 20 + 10) / 5;\n    var color = { h: this.hue, s: \"60%\", l: \"50%\" };\n    watercolor_context.strokeStyle =\n      \"hsla(\" + color.h + \",\" + color.s + \",\" + color.l + \",0.1)\";\n    watercolor_context.lineWidth = 2;\n    // trail은 한 번 그릴 때 5개씩 생기도록 함\n    for (var i = 0; i < 5; i++) {\n      watercolor_context.beginPath();\n      watercolor_context.moveTo(this.x, this.y);\n      var px = this.x + Math.cos(this.angle + 90) * (i * trail);\n      var py = this.y + Math.sin(this.angle + 90) * (i * trail);\n      watercolor_context.lineTo(px, py);\n      watercolor_context.stroke();\n    }\n\n    // index : 한 획을 그렸을 때, 펜이 떨어지는 위치의 좌표 값.\n    // ctx.getImageData.data 를 통해 얻어지는 1차원 행렬에 저장되어 있는 픽셀정보와 매핑됨\n    // 바로 직전의 drawing() 결과와 비교함.\n    // 픽셀정보 행렬에는 4개의 값이 하나의 픽셀을 표현함.\n    var index = (Math.floor(this.x) + width * Math.floor(this.y)) * 4;\n\n    // kill 조건\n    // 너무 세부적인 반복인 경우\n    if (this.gen >= this.life) this.kill();\n\n    // 펜을 뗀 픽셀의 알파가 0이 아닌 경우\n    if (data[index + 3] > 0) {\n      this.kill();\n    }\n\n    // 벽에 부딪힐 경우\n    if (this.x < 0 || this.x > width) this.kill();\n    if (this.y < 0 || this.y > height) this.kill();\n  };\n\n  // 배열에서 제거\n  this.kill = function () {\n    boids.splice(boids.indexOf(this), 1);\n    this.dead = true;\n  };\n};\n\nvar drawing = function (bubbleFrequency = 0.01) {\n  // 직전 틱의 canvas 상태를 가져온다.\n  image = roads_context.getImageData(0, 0, width, height);\n  data = image.data;\n  for (var i = 0; i < boids.length; i++) {\n    var boid = boids[i];\n    boid.update();\n    // 매 틱마다 2% 확률로 새로운 직선을 추가함.\n    // 완성된 직선에서 추가하는게 아니고 조금씩 그려가는 와중에 추가하는 것.\n    if (!boid.dead && Math.random() < bubbleFrequency && boids.length < 400) {\n      boids.push(\n        new Boid(\n          boid.x,\n          boid.y,\n          ((Math.random() > 0.5 ? 90 : -90) * Math.PI) / 180 + boid.angle,\n          boid.gen + 1\n        )\n      );\n    }\n  }\n  // 메인 캔버스에 그림을 그린다.\n  context.clearRect(0, 0, width, height);\n  context.globalAlpha = 0.5;\n  context.drawImage(watercolor_canvas, 0, 0);\n  context.globalAlpha = 1;\n  context.drawImage(roads_canvas, 0, 0);\n\n  if (boids.length == 0) {\n    clearInterval(drawingId);\n    drawingId = -1;\n    console.log(\"done\");\n  }\n};\n"]}